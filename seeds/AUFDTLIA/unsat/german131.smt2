(set-info :smt-lib-version 2.6)
(set-logic AUFDTLIA)
(set-info :source |
Generated by: Andrew Reynolds
Generated on: 2017-04-28
Generator: DVF, converted to v2.6 by CVC4
Application: Verification of security protocols and design architectures
Target solver: CVC4, Z3, Yices
Publications: "Finite Model Finding in SMT" by Andrew Reynolds, Cesare Tinelli, Amit Goel, and Sava Krstic, CAV 2013.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)


(declare-datatypes ((UNIT 0)) (((Unit))
))
(declare-datatypes ((BOOL 0)) (((Truth) (Falsity))
))
(declare-sort node$type 0)
(declare-sort data$type 0)
(declare-datatypes ((cache_state$type 0)) (((invalid) (shared) (exclusive))
))
(declare-datatypes ((cache$type 0)) (((c_cache$type (c_state cache_state$type) (c_data data$type)))
))
(declare-datatypes ((msg_cmd$type 0)) (((empty) (reqs) (reqe) (inv) (invack) (gnts) (gnte))
))
(declare-datatypes ((msg$type 0)) (((c_msg$type (m_cmd msg_cmd$type) (m_data data$type)))
))
(declare-fun dummy () data$type)
(declare-fun auxdata () data$type)
(declare-fun memdata () data$type)
(declare-fun cache () (Array node$type cache$type))
(declare-fun exgntd () BOOL)
(declare-fun invset () (Array node$type BOOL))
(declare-fun shrset () (Array node$type BOOL))
(declare-fun chan1 () (Array node$type msg$type))
(declare-fun chan2 () (Array node$type msg$type))
(declare-fun chan3 () (Array node$type msg$type))
(declare-fun curcmd () msg_cmd$type)
(declare-fun mk_array_1 () (Array node$type msg$type))
(assert (forall ((mk_array_1_index node$type)) (= (select mk_array_1 mk_array_1_index) (c_msg$type empty dummy)) ))
(declare-fun mk_array_2 () (Array node$type msg$type))
(assert (forall ((mk_array_2_index node$type)) (= (select mk_array_2 mk_array_2_index) (c_msg$type empty dummy)) ))
(declare-fun mk_array_3 () (Array node$type msg$type))
(assert (forall ((mk_array_3_index node$type)) (= (select mk_array_3 mk_array_3_index) (c_msg$type empty dummy)) ))
(declare-fun mk_array_4 () (Array node$type cache$type))
(assert (forall ((mk_array_4_index node$type)) (= (select mk_array_4 mk_array_4_index) (c_cache$type invalid dummy)) ))
(declare-fun mk_array_5 () (Array node$type BOOL))
(assert (forall ((mk_array_5_index node$type)) (= (select mk_array_5 mk_array_5_index) Falsity) ))
(declare-fun mk_array_6 () (Array node$type BOOL))
(assert (forall ((mk_array_6_index node$type)) (= (select mk_array_6 mk_array_6_index) Falsity) ))
(assert (not (=> (and (and (and (and (and (and (and (and (and (= auxdata dummy) (= memdata dummy)) (= curcmd empty)) (= exgntd Falsity)) (= shrset mk_array_6)) (= invset mk_array_5)) (= cache mk_array_4)) (= chan3 mk_array_3)) (= chan2 mk_array_2)) (= chan1 mk_array_1)) (forall ((n node$type)) (=> (or (= (m_cmd (select chan2 n)) inv) (= (m_cmd (select chan3 n)) invack)) (or (and (= curcmd reqs) (= exgntd Truth)) (= curcmd reqe))) ))))
(check-sat)
(exit)

