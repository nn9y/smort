(set-info :smt-lib-version 2.6)
(set-logic AUFBVDTLIA)
(set-info :source |
Generated by: Andrew Reynolds
Generated on: 2017-04-28
Generator: Nunchaku, Leon, CVC4, converted to v2.6 by CVC4
Application: Counterexample generation for higher-order theorem provers
Target solver: CVC4, Z3
Publications: "Model Finding for Recursive Functions in SMT" by Andrew Reynolds, Jasmin Christian Blanchette, Simon Cruanes, and Cesare Tinelli, IJCAR 2016.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)


(declare-datatypes ((Nat!2151 0)) (((succ!2152 (pred!2153 Nat!2151)) (zero!2154))
))
(declare-datatypes ((Lst!2155 0)) (((cons!2156 (head!2157 Nat!2151) (tail!2158 Lst!2155)) (nil!2159))
))
(declare-datatypes ((ZLst!2160 0)(Pair!2165 0)) (((zcons!2161 (zhead!2162 Pair!2165) (ztail!2163 ZLst!2160)) (znil!2164))
((mkpair!2166 (first!2167 Nat!2151) (second!2168 Nat!2151)))
))
(declare-fun error_value!2169 () ZLst!2160)
(declare-fun zip!288 (Lst!2155 Lst!2155) ZLst!2160)
(declare-fun error_value!2170 () Nat!2151)
(declare-fun head!209 (Lst!2155) Nat!2151)
(declare-fun error_value!2171 () Lst!2155)
(declare-fun tail!211 (Lst!2155) Lst!2155)
(declare-sort I_zip!288 0)
(declare-fun zip!288_arg_0_1 (I_zip!288) Lst!2155)
(declare-fun zip!288_arg_1_2 (I_zip!288) Lst!2155)
(declare-sort I_head!209 0)
(declare-fun head!209_arg_0_3 (I_head!209) Lst!2155)
(declare-sort I_tail!211 0)
(declare-fun tail!211_arg_0_4 (I_tail!211) Lst!2155)
(assert (forall ((?i I_zip!288)) (and (= (zip!288 (zip!288_arg_0_1 ?i) (zip!288_arg_1_2 ?i)) (ite ((_ is nil!2159) (zip!288_arg_0_1 ?i)) znil!2164 (ite ((_ is nil!2159) (zip!288_arg_1_2 ?i)) znil!2164 (ite (and ((_ is cons!2156) (zip!288_arg_1_2 ?i)) ((_ is cons!2156) (zip!288_arg_0_1 ?i))) (zcons!2161 (mkpair!2166 (head!2157 (zip!288_arg_0_1 ?i)) (head!2157 (zip!288_arg_1_2 ?i))) (zip!288 (tail!2158 (zip!288_arg_0_1 ?i)) (tail!2158 (zip!288_arg_1_2 ?i)))) error_value!2169)))) (ite ((_ is nil!2159) (zip!288_arg_0_1 ?i)) true (ite ((_ is nil!2159) (zip!288_arg_1_2 ?i)) true (ite (and ((_ is cons!2156) (zip!288_arg_1_2 ?i)) ((_ is cons!2156) (zip!288_arg_0_1 ?i))) (not (forall ((?z I_zip!288)) (not (and (= (zip!288_arg_0_1 ?z) (tail!2158 (zip!288_arg_0_1 ?i))) (= (zip!288_arg_1_2 ?z) (tail!2158 (zip!288_arg_1_2 ?i))))) )) true)))) ))
(assert (forall ((?i I_head!209)) (= (head!209 (head!209_arg_0_3 ?i)) (ite ((_ is cons!2156) (head!209_arg_0_3 ?i)) (head!2157 (head!209_arg_0_3 ?i)) error_value!2170)) ))
(assert (forall ((?i I_tail!211)) (= (tail!211 (tail!211_arg_0_4 ?i)) (ite ((_ is cons!2156) (tail!211_arg_0_4 ?i)) (tail!2158 (tail!211_arg_0_4 ?i)) error_value!2171)) ))
(assert (not (forall ((x!422 Nat!2151) (xs!423 Lst!2155) (ys!424 Lst!2155)) (or (= (zip!288 (cons!2156 (head!209 ys!424) xs!423) ys!424) (ite (= ys!424 nil!2159) znil!2164 (zcons!2161 (mkpair!2166 x!422 x!422) (zip!288 xs!423 (tail!211 ys!424))))) (forall ((?z I_zip!288)) (not (and (= (zip!288_arg_0_1 ?z) (cons!2156 (head!209 ys!424) xs!423)) (= (zip!288_arg_1_2 ?z) ys!424))) ) (forall ((?z I_head!209)) (not (= (head!209_arg_0_3 ?z) ys!424)) ) (not (ite (= ys!424 nil!2159) true (and (not (forall ((?z I_zip!288)) (not (and (= (zip!288_arg_0_1 ?z) xs!423) (= (zip!288_arg_1_2 ?z) (tail!211 ys!424)))) )) (not (forall ((?z I_tail!211)) (not (= (tail!211_arg_0_4 ?z) ys!424)) )))))) )))
(check-sat)
(exit)

