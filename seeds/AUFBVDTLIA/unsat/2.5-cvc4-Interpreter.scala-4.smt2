(set-info :smt-lib-version 2.6)
(set-logic AUFBVDTLIA)
(set-info :source |
Generated by: Andrew Reynolds
Generated on: 2017-04-28
Generator: Nunchaku, Leon, CVC4, converted to v2.6 by CVC4
Application: Counterexample generation for higher-order theorem provers
Target solver: CVC4, Z3
Publications: "Model Finding for Recursive Functions in SMT" by Andrew Reynolds, Jasmin Christian Blanchette, Simon Cruanes, and Cesare Tinelli, IJCAR 2016.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)


(declare-datatypes ((BoolTree!1006 0)(IntTree!1018 0)) (((And!1007 (t1!1008 BoolTree!1006) (t2!1009 BoolTree!1006)) (Eq!1010 (t1!1011 IntTree!1018) (t2!1012 IntTree!1018)) (Less!1013 (t1!1014 IntTree!1018) (t2!1015 IntTree!1018)) (Not!1016 (t!1017 BoolTree!1006)))
((Const!1019 (c!1020 (_ BitVec 32))) (If!1021 (cond!1022 BoolTree!1006) (t!1023 IntTree!1018) (e!1024 IntTree!1018)) (Minus!1025 (t1!1026 IntTree!1018) (t2!1027 IntTree!1018)) (Plus!1028 (t1!1029 IntTree!1018) (t2!1030 IntTree!1018)) (Var!1031 (index!1032 (_ BitVec 32))))
))
(declare-fun error_value!1033 () Bool)
(declare-fun error_value!1034 () (_ BitVec 32))
(declare-fun beval!210 (BoolTree!1006 (_ BitVec 32)) Bool)
(declare-fun repOk!206 (IntTree!1018) Bool)
(declare-fun treeBad!219 (IntTree!1018) Bool)
(declare-fun identityForPositive!217 (IntTree!1018) Bool)
(declare-fun ieval!213 (IntTree!1018 (_ BitVec 32)) (_ BitVec 32))
(declare-fun computesPositive!215 (IntTree!1018) Bool)
(assert (forall ((t!208 BoolTree!1006) (x0!209 (_ BitVec 32))) (= (beval!210 t!208 x0!209) (ite ((_ is Less!1013) t!208) (bvslt (ieval!213 (t1!1014 t!208) x0!209) (ieval!213 (t2!1015 t!208) x0!209)) (ite ((_ is Eq!1010) t!208) (= (ieval!213 (t1!1011 t!208) x0!209) (ieval!213 (t2!1012 t!208) x0!209)) (ite ((_ is And!1007) t!208) (and (and (beval!210 (t1!1008 t!208) x0!209) (beval!210 (t1!1008 t!208) x0!209)) (beval!210 (t2!1009 t!208) x0!209)) (ite ((_ is Not!1016) t!208) (not (beval!210 (t!1017 t!208) x0!209)) error_value!1033))))) ))
(assert (forall ((t!205 IntTree!1018)) (= (repOk!206 t!205) true) ))
(assert (forall ((t!218 IntTree!1018)) (= (treeBad!219 t!218) (not (and (and (and (repOk!206 t!218) (repOk!206 t!218)) (computesPositive!215 t!218)) (identityForPositive!217 t!218)))) ))
(assert (forall ((t!216 IntTree!1018)) (= (identityForPositive!217 t!216) (and (and (= (ieval!213 t!216 (_ bv5 32)) (_ bv5 32)) (= (ieval!213 t!216 (_ bv5 32)) (_ bv5 32))) (= (ieval!213 t!216 (_ bv33 32)) (_ bv33 32)))) ))
(assert (forall ((t!211 IntTree!1018) (x0!212 (_ BitVec 32))) (= (ieval!213 t!211 x0!212) (ite ((_ is Const!1019) t!211) (c!1020 t!211) (ite ((_ is Var!1031) t!211) (ite (= (index!1032 t!211) (_ bv0 32)) x0!212 (_ bv0 32)) (ite ((_ is Plus!1028) t!211) (bvadd (ieval!213 (t1!1029 t!211) x0!212) (ieval!213 (t2!1030 t!211) x0!212)) (ite ((_ is Minus!1025) t!211) (bvsub (ieval!213 (t1!1026 t!211) x0!212) (ieval!213 (t2!1027 t!211) x0!212)) (ite ((_ is If!1021) t!211) (ite (beval!210 (cond!1022 t!211) x0!212) (ieval!213 (t!1023 t!211) x0!212) (ieval!213 (e!1024 t!211) x0!212)) error_value!1034)))))) ))
(assert (forall ((t!214 IntTree!1018)) (= (computesPositive!215 t!214) (and (and (and (bvsge (ieval!213 t!214 (_ bv0 32)) (_ bv0 32)) (bvsge (ieval!213 t!214 (_ bv0 32)) (_ bv0 32))) (bvsge (ieval!213 t!214 (_ bv1 32)) (_ bv0 32))) (bvsge (ieval!213 t!214 (_ bv2 32)) (_ bv0 32)))) ))
(assert (not (not (treeBad!219 (If!1021 (Less!1013 (Const!1019 (_ bv0 32)) (Var!1031 (_ bv0 32))) (Var!1031 (_ bv0 32)) (Minus!1025 (Const!1019 (_ bv0 32)) (Var!1031 (_ bv0 32))))))))
(check-sat)
(exit)

