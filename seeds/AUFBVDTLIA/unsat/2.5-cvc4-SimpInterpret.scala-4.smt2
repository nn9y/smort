(set-info :smt-lib-version 2.6)
(set-logic AUFBVDTLIA)
(set-info :source |
Generated by: Andrew Reynolds
Generated on: 2017-04-28
Generator: Nunchaku, Leon, CVC4, converted to v2.6 by CVC4
Application: Counterexample generation for higher-order theorem provers
Target solver: CVC4, Z3
Publications: "Model Finding for Recursive Functions in SMT" by Andrew Reynolds, Jasmin Christian Blanchette, Simon Cruanes, and Cesare Tinelli, IJCAR 2016.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)


(declare-datatypes ((BoolTree!1001 0)(IntTree!1013 0)) (((And!1002 (t1!1003 BoolTree!1001) (t2!1004 BoolTree!1001)) (Eq!1005 (t1!1006 IntTree!1013) (t2!1007 IntTree!1013)) (Less!1008 (t1!1009 IntTree!1013) (t2!1010 IntTree!1013)) (Not!1011 (t!1012 BoolTree!1001)))
((Const!1014 (c!1015 (_ BitVec 32))) (If!1016 (cond!1017 BoolTree!1001) (t!1018 IntTree!1013) (e!1019 IntTree!1013)) (Minus!1020 (t1!1021 IntTree!1013) (t2!1022 IntTree!1013)) (Plus!1023 (t1!1024 IntTree!1013) (t2!1025 IntTree!1013)) (Var!1026))
))
(declare-fun error_value!1027 () Bool)
(declare-fun error_value!1028 () (_ BitVec 32))
(declare-fun beval!210 (BoolTree!1001 (_ BitVec 32)) Bool)
(declare-fun repOk!206 (IntTree!1013) Bool)
(declare-fun treeBad!219 (IntTree!1013) Bool)
(declare-fun identityForPositive!217 (IntTree!1013) Bool)
(declare-fun ieval!213 (IntTree!1013 (_ BitVec 32)) (_ BitVec 32))
(declare-fun computesPositive!215 (IntTree!1013) Bool)
(assert (forall ((t!208 BoolTree!1001) (x0!209 (_ BitVec 32))) (= (beval!210 t!208 x0!209) (ite ((_ is Less!1008) t!208) (bvslt (ieval!213 (t1!1009 t!208) x0!209) (ieval!213 (t2!1010 t!208) x0!209)) (ite ((_ is Eq!1005) t!208) (= (ieval!213 (t1!1006 t!208) x0!209) (ieval!213 (t2!1007 t!208) x0!209)) (ite ((_ is And!1002) t!208) (and (and (beval!210 (t1!1003 t!208) x0!209) (beval!210 (t1!1003 t!208) x0!209)) (beval!210 (t2!1004 t!208) x0!209)) (ite ((_ is Not!1011) t!208) (not (beval!210 (t!1012 t!208) x0!209)) error_value!1027))))) ))
(assert (forall ((t!205 IntTree!1013)) (= (repOk!206 t!205) true) ))
(assert (forall ((t!218 IntTree!1013)) (= (treeBad!219 t!218) (not (and (and (and (repOk!206 t!218) (repOk!206 t!218)) (computesPositive!215 t!218)) (identityForPositive!217 t!218)))) ))
(assert (forall ((t!216 IntTree!1013)) (= (identityForPositive!217 t!216) (and (and (and (and (and (= (ieval!213 t!216 (_ bv5 32)) (_ bv5 32)) (= (ieval!213 t!216 (_ bv5 32)) (_ bv5 32))) (= (ieval!213 t!216 (_ bv33 32)) (_ bv33 32))) (= (ieval!213 t!216 (_ bv0 32)) (_ bv0 32))) (= (ieval!213 t!216 (_ bv4294967295 32)) (_ bv1 32))) (= (ieval!213 t!216 (_ bv4294967294 32)) (_ bv2 32)))) ))
(assert (forall ((t!211 IntTree!1013) (x0!212 (_ BitVec 32))) (= (ieval!213 t!211 x0!212) (ite ((_ is Const!1014) t!211) (c!1015 t!211) (ite ((_ is Var!1026) t!211) x0!212 (ite ((_ is Plus!1023) t!211) (bvadd (ieval!213 (t1!1024 t!211) x0!212) (ieval!213 (t2!1025 t!211) x0!212)) (ite ((_ is Minus!1020) t!211) (bvsub (ieval!213 (t1!1021 t!211) x0!212) (ieval!213 (t2!1022 t!211) x0!212)) (ite ((_ is If!1016) t!211) (ite (beval!210 (cond!1017 t!211) x0!212) (ieval!213 (t!1018 t!211) x0!212) (ieval!213 (e!1019 t!211) x0!212)) error_value!1028)))))) ))
(assert (forall ((t!214 IntTree!1013)) (= (computesPositive!215 t!214) (and (and (and (and (and (bvsge (ieval!213 t!214 (_ bv0 32)) (_ bv0 32)) (bvsge (ieval!213 t!214 (_ bv0 32)) (_ bv0 32))) (bvsge (ieval!213 t!214 (_ bv1 32)) (_ bv0 32))) (bvsge (ieval!213 t!214 (_ bv4294967295 32)) (_ bv0 32))) (bvsge (ieval!213 t!214 (_ bv4294967294 32)) (_ bv0 32))) (bvsge (ieval!213 t!214 (_ bv2 32)) (_ bv0 32)))) ))
(assert (not (not (treeBad!219 (If!1016 (Less!1008 (Const!1014 (_ bv0 32)) Var!1026) Var!1026 (Minus!1020 (Const!1014 (_ bv0 32)) Var!1026))))))
(check-sat)
(exit)

